%!TEX root = bare_conf.tex
\section{Introduction}\label{sec:intro}
Memory leak is well-known to be a major cause of reliability and performance issues in software, for example in embedded systems, as it causes the long-running applications or embedded systems eventually run out of memory. 
A system running out of memory may lead to the slowing down of the system caused by frequently swapping in and out and process creation failure because of no more memory available. Moreover, memory leaks have caused severe consequences in some large applications and services. For example, in September 1992 in London, a memory leak in the ambulance service system~\cite{F93} resulted in a system crash, which led to the system breakdown after three weeks of continuous program operating. On October 22, 2012, a potential memory leak caused Amazon's EC2 cloud services to be partially disrupted, which affected the operations of hundreds of EC2 customers\footnote{http://iguowei.com/2012/11/22/amazon-service-event/. 2017.}. 
Therefore, detecting memory leaks is very important and necessary to ensure the quality of software. Although memory leaks do not typically constitute a direct security threat, attackers can exploit them to increase a denial-of-service attack’s effectiveness.
However, detecting memory leaks is challenging, as the only symptom of memory leak is the slow increasing in memory consumption.  

To address this challenge, there are two general techniques in existing works - dynamic testing and static source code analysis~\cite{AJ06}. 
Compared to dynamic testing analysis which relies on the coverage of the test cases and requires long-time execution, static source code analysis has the advantage of higher accuracy, because static analysis is usually to find the memory allocation location and the corresponding release point.
%In fact, source code analysis is an important approach for detecting many vulnerabilities (including memory leaks) in software. 
Therefore, we focus on detecting memory leaks by applying source code analysis.
Among program source codes written in various languages, detecting memory leak is particularly necessary when the program is written in low-level programming languages such as C/C++. Because the low-level programming languages allow manual memory management, for example explicit memory allocation and deallocation~\cite{KJMP06}. Such manual memory operations are often error-prone which lead to vulnerabilities. 
%There has been previous related works on this problem~\cite{}.
%However, they become inefficient and less acurrate when complex control flows are involved. 

The root cause of vulnerabilities can be summarised as the relation between memory allocation and deallocation directly or indirectly caused by explicit memory operations, that is whether the following two points have been followed~\cite{AJ06}.
\begin{itemize}
\item	The dynamic memory blocks are not free/deallocated.
\item	The dynamic memory blocks are freed in wrong order.
\end{itemize}
To check the above two errors, there are in general the following approaches: value-flow-based approach and control-flow-based approach. The basic idea of value-flow-based approach is to capture def-use chains and value flows via assignments for all memory locations represented by both top-level and address-taken pointers, which is also known as VFG (Value Flow Graph). While the basic idea of control-flow-based approach is to construct a model that represents the dynamic memory allocation and deallocation on the CFG (Control Flow Graph). Based on the CFG model, we check whether a block of heap memory space is reclaimed by the program or the run-time system when the lifetime of the program has ended - if a block is not reclaimed, then there is memory leak. Compared the VFG model~\cite{SYX12} with the projection-based CFG model, the latter focuses on all the possible execution paths, analyzes the lifetime of pointers that assigned memory locations. %We provide more detailed description for each type of memory leak in this model.
In particular, we take into account the memory pointers' lifecycle, i.e., including all the memory operations, in order to capture the indirect allocation-deallocation relation and thus obtain accurate results.

The existing control-flow-based approach has limitations in efficiency and accuracy when the control flow is getting complex, because the analysis of complex control flow needs to deal with a large number of path branches. %In this paper, we propose a concept named ``complex control flow'' in program analysis of memory leaks. 
We say that the control flows of a program is complex if the allocation and deallocation appear in different control flow branches of a program, and thus memory leaks are more likely to happen. Due to the complexity of the branch conditions' analysis, complex control flows make memory detection more difficult. %The complex control flow structures considered in this paper include the cases that the circulation complexity of a CFG (control flow graph) is not less than 2.
%Existing works have limitations  when the targeted program has complex control flows. 
In this work, we focus on efficiently and accurately detecting memory leaks in programs with complex control flows.  

%The complexity of control flows of a program is closely related to the 
% the complexity of the program.
%The more complex the program is, the more complex the control flow of the program is.
%, and is also highly related to the number of software vulnerabilities. 
 
The higher complexity of the control flows is, the easier the vulnerabilities can hide. To detect memory leaks, we need to search each control flow. Thus, the difficulty of detecting memory leaks in complex control flows increases with the complexity of paths in the control flows. Properly reducing the complexity of a program’s control flows can greatly improve the efficiency and accuracy of detecting memory leaks in the program. Therefore, in this work, we propose to apply projection to the control flow graph of a program. The projection abstracts the original control flow graph to a simplified graph so to reduce the complexity of searching control flows in memory detection. The main challenge in the abstraction is to ignore the irrelevant paths. To address this challenge, when a program has multiple control flow branches, we need to evaluate the condition value of each control flow branch node and then analyze the execution results of different branch paths according to different conditions. To do so, we adopt path-sensitive analysis method~\cite{XA05}, which records the different program states of the two branch paths by tracing each branch of the program control flow. This method analyzes the combinatorial relation between branches, which can be used to identify all the paths in a control flow graph. In other words, this method will abstract away some paths that are irrelevant to memory operations by matching the defined expression. A key issue in path-sensitive analysis is the evaluation of the guiding conditions of paths. To address this issue, we use a tool named PAT (Path Analysis and Testing)~\cite{H87}, which uses symbolic execution and constraint solving, to perform accurate evaluation on branch evaluations. %, but this two methods need sufficient time and space resources, and it is not suitable for more complex control flows analysis.
As a result, we propose a set of rules for guiding the projection which essentially reduces irrelevant nodes in a control flow graph, and we prove the correctness of the rules -  no irrelevant path is considered and no relevant path is ignored.

%In order to achieve the accurate analysis for memory leaks in multiple control flow structures, in this paper, the idea of projection is applied to the analysis of control flow graphs. The abstract syntax tree is generated after the program lexical, syntax analysis. Our approach projects the original control flow graph to a simplified graph for reducing the analysis complexity based on abstract syntax tree. During the process of detecting memory leaks, we use the bottom-up approach to find bugs in the projection graphs.

In the next section we introduce our control flow graphs projection approach and prove its effectiveness. In Section~\ref{sec:description}, we analyze the causes of memory leaks and describe a leak model from the perspective of path-abstraction. Section~\ref{sec:approach} mainly presents the projection algorithm and memory leaks detection algorithm. In Section~\ref{sec:experiments}, we conduct some experiments to test PML\_Checker by comparing with other detection tools, and we evaluate it at its effectiveness, accuracy, run time and scalability. Section~\ref{sec:related} discusses related research. And finally we conclude this work in Section~\ref{sec:conclusion}.
