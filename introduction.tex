%!TEX root = bare_conf.tex
\section{Introduction}\label{sec:intro}
Memory leak is a major cause of reliability and performance issues in software. Especially in embedded systems, since it causes the long-running applications, which eventually will run out of memory. 
A system running out of memory may lead to the slowing down of the system caused by frequently swapping in and out and process creation failure because of no more memory available. Moreover, memory leaks have caused severe consequences in some large applications and services. For example, on October 22, 2012, in the US-East region, a potential memory leak caused Amazon Elastic Block Store (EBS) and Elastic Compute Cloud (EC2) services to be six hours partially disrupted, and during this time services can not handle IO requests\footnote{ AWS Service Event.https://aws.amazon.com/cn/message/680342/.2017.}. 
Therefore, detecting memory leaks is very important and necessary to ensure the quality of software. Although memory leaks do not typically constitute a direct security threat, attackers can exploit them to increase a denial-of-service attack’s effectiveness.
However, detecting memory leaks is challenging, since the only symptom of memory leak is the slow increasing in memory consumption.  

To address this challenge, there are two general techniques in existing works---dynamic testing and static source code analysis~\cite{AJ06}. 
Dynamic testing relies on the coverage of the test cases and requires long-time execution. Comparing to dynamic testing, static source code analysis has the advantage of higher accuracy, because static analysis is usually to find the memory allocation location and the corresponding release point.
%In fact, source code analysis is an important approach for detecting many vulnerabilities (including memory leaks) in software. 
Therefore, this paper focuses on detecting memory leaks by applying source code analysis.
Among program source codes written in various languages, detecting memory leaks is particularly necessary when the program is written in low-level programming languages such as C/C++. Because the low-level programming languages allow manual memory management, for example explicit memory allocation and deallocation~\cite{KJMP06}. Such manual memory operations are often error-prone which lead to vulnerabilities. 
%There has been previous related works on this problem~\cite{}.
%However, they become inefficient and less acurrate when complex control flows are involved. 

The relationship between memory allocation and deallocationThe can describe the root cause of memory leak. In other words, the following two points show the classification of memory-leak reasons~\cite{LCW13}.
\begin{itemize}
\item[$\textbf{\emph{a.}}$]The dynamic memory blocks are not free/deallocated.
\item[$\textbf{\emph{b.}}$]The dynamic memory blocks are freed in wrong order.
\end{itemize}

To check the above two errors, there are in general the following approaches: value-flow-based approach and control-flow-based approach. The basic idea of value-flow-based approach is to capture def-use chains and value flows via assignments for all memory locations represented by both top-level and address-taken pointers, which is also known as VFG (Value Flow Graph). While the basic idea of control-flow-based approach is to construct a model that represents the dynamic memory allocation and deallocation on the CFG (Control Flow Graph). Based on the CFG model, this paper checks whether a block of heap memory space is reclaimed by the program or the run-time system when the lifetime of the program has ended - if a block is not reclaimed, then there is memory leak. Comparing the VFG model~\cite{SYX12} with the projection-based CFG model, the latter focuses on all the possible execution paths, analyzes the lifetime of pointers that assigned memory locations. %We provide more detailed description for each type of memory leak in this model.
In particular, this paper takes into account the memory pointers' lifecycle, i.e., including all the memory operations, in order to capture the indirect allocation-deallocation relation and thus obtain accurate results.

The existing control-flow-based approaches have limitations in efficiency and accuracy when the control flow is getting complex, because the analysis of complex control flow needs to deal with a large number of path branches. %In this paper, we propose a concept named ``complex control flow'' in program analysis of memory leaks. 
We say that the control flows of a program is complex if the allocation and deallocation appear in different control flow branches of a program, and thus memory leaks are more likely to happen. Due to the complexity of the branch conditions' analysis, complex control flows make memory detection more difficult. %The complex control flow structures considered in this paper include the cases that the circulation complexity of a CFG (control flow graph) is not less than 2.
%Existing works have limitations  when the targeted program has complex control flows. 
In this work, this paper focuses on efficiently and accurately detecting memory leaks in programs with complex control flows.  
%The complexity of control flows of a program is closely related to the 
% the complexity of the program.
%The more complex the program is, the more complex the control flow of the program is.
%, and is also highly related to the number of software vulnerabilities. 
 
The higher complexity of the control flows is, the easier the vulnerabilities can hide. To detect memory leaks, detection system needs to search each control flow. Thus, the difficulty of detecting memory leaks in complex control flows increases with the complexity of paths in the control flows. Properly reducing the complexity of programs’ control flows can greatly improve the efficiency and accuracy of detecting memory leaks in the program. Therefore, in this work, this paper proposes to apply projection to the control flow graph of a program. The projection abstracts the original control flow graph to a simplified graph to reduce the complexity of searching control flows in memory detection. The main challenge in the abstraction is to ignore the irrelevant paths. To address this challenge, when program has complex control flow branches, detecting system needs to evaluate the condition value of each control flow branch node, and then analyze the execution results of different branch paths according to different conditions. In order to achieve this goal, our system adopts path-sensitive analysis method~\cite{XA05}. This method records different program states of complex branch paths by tracing each branch of the program control flow. This method analyzes the combinatorial relationship between branches. Thus the path-sensitive analysis method identify all the paths in a control flow graph. In other words, this method will abstract away some paths that are irrelevant to memory operations by matching the defined expression. A key issue in path-sensitive analysis is the evaluation of the guiding conditions of paths. To address this issue, our system uses a tool named PAT (Path Analysis and Testing)~\cite{ZW01}, which uses symbolic execution and constraint solving, to perform accurate evaluation on branch evaluations. %, but this two methods need sufficient time and space resources, and it is not suitable for more complex control flows analysis.
As a result, this paper proposes a set of rules for guiding the projection which essentially reduces irrelevant nodes in a control flow graph, and proves the correctness of the rules -  no irrelevant path is considered and no relevant path is ignored.

%In order to achieve the accurate analysis for memory leaks in multiple control flow structures, in this paper, the idea of projection is applied to the analysis of control flow graphs. The abstract syntax tree is generated after the program lexical, syntax analysis. Our approach projects the original control flow graph to a simplified graph for reducing the analysis complexity based on abstract syntax tree. During the process of detecting memory leaks, we use the bottom-up approach to find bugs in the projection graphs.

The main contributions of this paper can be summarized as follows:
\begin{itemize}
\item The classification of memory leaks, particularly in source code with complex control flows.
\item A projection-based approach to detect potential memory leaks in C program, reducing the false negative rate in the program with complex control flows.
\item A detecting tool---PML\_Checker, evaluating the effectiveness and accuracy of the tool on public benchmarks (SPEC CPU 2000, SIR and SARD). 
\end{itemize}

In the next section this paper introduce our control flow graphs projection approach and prove its effectiveness. Section~\ref{sec:description} analyzes the causes of memory leaks and describe a leak model from the perspective of path-abstraction. Section~\ref{sec:approach} mainly presents the projection algorithm and memory leaks detection algorithm. In Section~\ref{sec:experiments}, we conduct some experiments to test PML\_Checker by comparing with other detection tools, and we evaluate it at its effectiveness, accuracy, run time and scalability. Section~\ref{sec:related} discusses related research. And finally we conclude this work in Section~\ref{sec:conclusion}.
