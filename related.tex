%!TEX root = bare_conf.tex
\section{Related Works}\label{sec:related}

\subsection{Approaches on Static Detection}
Currently, the common approaches~\cite{YZ04} used in static memory detection include symbolic execution followed by constraint solving, type inference\footnote{Type inference. https://en.wikipedia.org/wiki/Type\_inference. 2017.}, rule-based inspection~\cite{SJP05}, besides those mentioned in the previous section. However, all these approaches have limitations when dealing with large scale programs. For symbolic execution, the number of paths will increase exponentially with the increase of the program size, which leads to problems such as ``path-explosion" and ``infinite-search-space", and thus increases the time complexity of entire detection. Type inference automatically derives the type of variables by tools, this approach is suitable for analyzing large scale programs, but it is not applicable to the control flow analysis. Compare to this approach, CFG based approach, that we are following, is more intuitive and accurate in detecting memory leaks. Regarding rule-based inspection, its scalability is poor due to that describing a program into rules is complicated and error-prone. 

\subsection{Tools on Static Detection}
We also survey the static detection tools particularly for memory leaks detection. Noted that one tool may adopt multiple approaches. We highlight some well-known tools as follows. One of them is Prefix~\cite{BPS00}, which is embedded in the Visual Studio. Prefix detects memory leaks by symbolic simulation. It is path-sensitive and uses function summaries for scalability. However, Prefix explores one path at a time, which becomes inefficient when procedures have many paths. %Heuristics limit the search to a small set of paths. 
Some other tools show a high analysis accuracy by using different techniques. For instance, Splint and CppCheck use the rule-based approach, where Splint mainly analyzes style and annotations of program, and CppCheck detects errors by matching expressions. As an example of flow-sensitive approach, tool Cqual\footnote{Cqual. http://www.cs.umd.edu/~jfoster/cqual/. 2004.} uses type inference and constraint solving techniques for improve accuracy. These tools essentially check the potential memory leaks by adding annotations for the access operation in the source programs. This approach has high preciseness, however, it will generate many false positives as the complexity of the program increases, because the annotations added cannot be reused. Tool RL\_Detector~\cite{J14} detects resource leaks in C programs. It improves detection efficiency by constructing resource behavior to streamline slices, this method retains all statements that are allocated and deallocated of resources, as well as the statements that affect the use of the resource (including memory). Our tool is based on~\cite{XA05,YZ04}, and combines approaches such as symbolic execution, which are used in the above tools as well. Compared with existing work, our tool is specific for detecting memory leaks in C programs, especially in the program with complex control flows. 

\subsection{Regarding the Complex Control Flow Concept}
There are few studies on complex control flow in the field of static analysis. As in~\cite{KJMP06}, this concept is mainly used in the process of dynamic testing to predict some frequently executed paths, in order to eliminate false positive caused by the evaluating the conditional branches. In~\cite{KK12}, the concept is only used to show a method to measure the complexity of programs, which is irrelevant to memory detection. %in complex control flows. 

\subsection{Research on Projection in Program Analysis}
In the field of program analysis, especially in the detection of program dynamic memory leaks, the researchers are more inclined to adopt the dynamic memory modeling methods. For example, \cite{KK16} builds a heap abstraction model that restrains the heap model by combining multiple abstraction positions into a summary position, however in practical applications, there is still a great gap on accuracy between the results of this method and the exact results. \cite{WJG14} builds a pointer behavior model, this model utilizes model checking tools to verify the reachability of assertions to analyzing memory leaks. \cite{MFS12} builds a bounded model, where the memory leaks properties are added. This method transforms the memory leaks problem into solving satisfiability problem, thereby achieves the memory leaks detection. However, this detection scheme needs to reduce the generated verification space and accordingly improve the accuracy of verify. Our approach builds a program model, which is used to be traversed and stored into the stack following some rules for detecting memory leaks.

In recent years, the idea of projection is often applied to computer vision~\cite{W05}, mathematical model selection~\cite{NL10} and other related research fields due to its close relationship with graphs. There are only a few of papers use the projection method in the program analysis. \cite{D94} analyzes the specification and abortion of programs by the projection of functions. While in terms of security, this paper only takes a conservative analysis, in other words, the output is ``uncertain” or ``unknown” for some uncertain input, which is relatively fuzzy, so the accuracy of the analysis results need to be improved. \cite{H87} detects dead cycles in control flows and confusion in data flows by projecting the control flow graphs. In our approach, we redefine the projection of the program control flow graphs, and solve security problems with a specific algorithm for detecting memory leaks.
